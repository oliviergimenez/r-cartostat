[
["index.html", "Cartographie avec R à l’usage des statisticiens Introduction Objectifs Ressources Licence", " Cartographie avec R à l’usage des statisticiens Thomas Vroylandt 7 février 2020 Introduction Ce support a été rédigé par Thomas Vroylandt, statisticien au sein de la Direction des Statistiques, des Etudes et de l’Evaluation de Pôle emploi. Objectifs Ce guide vise à : introduire quelques notions sur les données spatiales ; permettre de représenter des valeurs sous forme de cartes par aplats de couleurs ; permettre de représenter des valeurs sous forme de cartes à ronds proportionnels ; personnaliser ces cartes ; exporter les résultats pour publication. Ressources Ces ressources ont servis à construire ce support : Le support de cours réalisé par Maël Theulière a été une grande référence. La partie sur les projets dans R est en tirée : https://maeltheuliere.github.io/rspatial/ ; Tout savoir sur le spatial avec R : https://geocompr.robinlovelace.net/ ; La ressource sur les recodages et le maniement des données : https://r4ds.had.co.nz/ (en anglais) ; Une bonne introduction, qui a notamment servie pour la partie recodages : https://juba.github.io/tidyverse/ (en français). Licence Ce document est sous licence Creative Commons BY-NC-SA : http://creativecommons.org/licenses/by-nc-sa/4.0/ "],
["tldr.html", "TL;DR", " TL;DR Ce chapître résume d’un bloc comment on peut réaliser une carte avec R. On charge les packages. library(tidyverse) library(readxl) library(sf) library(here) On charge les données et on les recode si besoin. bmo_secteur &lt;- read_xlsx(&quot;data/dataset/bmo_2019_secteur.xlsx&quot;) bmo_dep &lt;- bmo_secteur %&gt;% group_by(dep) %&gt;% summarise(nb_proj_tot = sum(nb_proj_tot), nb_proj_diff = sum(nb_proj_diff)) %&gt;% mutate( part_diff = nb_proj_diff / nb_proj_tot * 100, part_diff_classes = cut( part_diff, include.lowest = TRUE, breaks = c(0, 40, 50, 60, 100), labels = c(&quot;Moins de 40 %&quot;, &quot;40-50 %&quot;, &quot;50-60 %&quot;, &quot;60% et plus&quot;) ) ) On importe le fond de carte. shp_dep &lt;- st_read(here(&quot;data/shp/FR_DEP_DOM_IDF.shp&quot;)) ## Reading layer `FR_DEP_DOM_IDF&#39; from data source `D:\\r-cartostat\\data\\shp\\FR_DEP_DOM_IDF.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 109 features and 3 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 101171.8 ymin: 5991180 xmax: 1242086 ymax: 7283392 ## epsg (SRID): NA ## proj4string: +proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +units=m +no_defs On les fusionne. bmo_dep_shp &lt;- shp_dep %&gt;% left_join(bmo_dep, by = c(&quot;code_dep&quot; = &quot;dep&quot;)) ## Warning: Column `code_dep`/`dep` joining factor and character vector, coercing into character vector On réalise la carte, par exemple par aplat de couleur. Avec les élements d’échelles et de thème. ggplot() + geom_sf(data = bmo_dep_shp, aes(fill = part_diff_classes)) + scale_fill_viridis_d(name = &quot;&quot;, option = &quot;inferno&quot;, direction = -1) + labs(title = &quot;Part des projets difficiles&quot;, caption = &quot;Source : BMO 2019&quot;) + theme_void() Ou par cercles proportionnels. ggplot(data = bmo_dep_shp) + geom_sf() + stat_sf_coordinates(aes(size = nb_proj_tot, color = part_diff)) + scale_color_viridis_c(name = &quot;Part des projets difficiles&quot;, option = &quot;plasma&quot;, direction = -1) + scale_size_continuous(range = c(1, 10), name = &quot;Nombre de projets&quot;) + labs(caption = &quot;Source : BMO 2019&quot;) + theme_void() On exporte. ggsave( filename = &quot;chemin/nom_du_fichier.png&quot;, width = 297, height = 210, units = &quot;mm&quot;, dpi = 400 ) "],
["preliminaires.html", "1 Préliminaires 1.1 Installer R et Rstudio 1.2 Fonctionner en projet 1.3 Utiliser un package", " 1 Préliminaires 1.1 Installer R et Rstudio 1.1.1 R Du fait des blocages sur les postes de Pôle emploi, pour télécharger R, on doit utiliser l’installeur mis à disposition par la DSI, puis mettre à jour manuellement le logiciel. On dézippe l’installateur dans le D://. Puis on ouvre R et on tape les instructions suivantes : install.packages(&quot;installr&quot;) installr::updateR() Cela met à jour R et va créer un nouveau dossier avec la nouvelle version dans le D://. Il est plus simple de mettre à jour R avant d’installer RStudio. 1.1.2 Rstudio On téléchargera le logiciel au format .zip ici : https://download1.rstudio.org/desktop/windows/RStudio-1.2.5033.zip Il faut ensuite dézipper l’archive dans votre D:// On ouvre ensuite le programme Rstudio.exe situé dans le dossier bin de votre dossier Rstudio. Pensez à créer un raccourci vers ce programme dans votre barre d’accès rapide par exemple. On s’assure qu’il trouve bien le programme R. Sinon il faut lui indiquer l’emplacement du dossier R 3.5.XXX dans le D://. Assurez-vous d’avoir réalisé ces étapes avant la formation. 1.2 Fonctionner en projet 1.2.1 Les projets dans RStudio Pourquoi travailler avec les projets Rstudio plutôt que les scripts R ? Pour la portabilité : le répertoire de travail par défaut d’un projet est le répertoire où est ce projet. Si vous transmettez celui-ci à un collègue, le fait de lancer un programme ne dépend pas de l’arborescence de votre machine : Fini les setwd(\"chemin/qui/marche/uniquement/sur/mon/poste\") ! Pour l’organisation : un projet permet de structurer son analyse de façon plus simple et de diviser le travail entre différents sujets. Pour aller plus loin : les packages, le versioning avec Git, les applications Shiny, tout cela fonctionne dans des projets. Les utiliser maintenant vous facilitera la tâche plus tard. Pour créer un projet : Cliquez sur Project en haut à droite puis New Project. Cliquez sur New Directory. 1.2.2 Désactiver les options de sauvegarde automatique de RStudio Votre code doit être reproductible depuis vos données en entrée vers votre résultat. Pour cela, il est fortement déconseillé de sauvegarder quoique ce soit dans le fichier .RData de sauvegarde par défaut. Pour cela, aller dans Tools-&gt;Global Options… et ensuite conformez vous à ceci 1.2.3 Organiser votre travail Organisez votre projet en créant plusieurs répertoires à l’intérieur de celui-ci (les noms sont des exemples) : data pour vos données ; R ou src pour vos scripts ; figures ou output pour vos sorties. En suivant une telle architecture pour tous vos projets, cela vous permettra d’aller plus vite. 1.3 Utiliser un package R fonctionne selon une logique de modules, appelés “packages”. Ils apportent de nouvelles fonctionnalités à la version de base. 1.3.1 Installer les packages La première étape est donc d’installer les packages qui nous sont utiles pour réaliser des cartes. Cette opération se réalise une fois et il n’est pas nécessaire de la répéter (cela mettra à jour le package). Pour cela, on peut soit : Utiliser RStudio qui nous propose un outil d’installation dans Tools &gt; Install Packages …. Tapez le nom des packages qui vous intéressent, séparés par un espace et appuyez sur Install. Installer les packages en ligne de commande comme ce qui suit install.packages(c(\"sf\", \"tidyverse\")) (pour installer les packages sf et tidyverse). Pour faire des cartes, on va se servir de plusieurs packages : sf qui est dédié à l’analyse spatiale ; tidyverse qui installe et charge d’un seul coup plusieurs packages utiles, dont : dplyr pour la manipulation de données ; forcats pour le recodage des facteurs ; readr pour l’import de données ; ggplot2 pour faire des graphiques. Et en fonction du format d’import des données : readxl pour importer des fichiers Excel (.xls ou .xlsx) ; haven pour importer des tables SAS ; here pour gérer les chemins. Merci d’installer ces packages avant la formation, par exemple avec la commande install.packages(c(\"sf\", \"tidyverse\", \"readxl\", \"haven\", \"here\")) 1.3.2 Charger les packages On les charge dans R à l’aide de l’instruction library(nom_du_package) comme dans le code suivant : library(tidyverse) library(sf) library(readxl) library(haven) library(here) Cela peut renvoyer une erreur, par exemple : library(tidyverses) ## Error in library(tidyverses): there is no package called &#39;tidyverses&#39; Dans ce cas, vérifiez l’orthographe du package. Si l’erreur persiste, vous avez peut-être oublié de l’installer. Quand on utilise une fonction d’un package, on doit préalablement le déclarer avec library() sinon cela renvoiera une erreur. "],
["import-data.html", "2 Préparer vos données 2.1 Importer des données 2.2 Pour la cartographie", " 2 Préparer vos données 2.1 Importer des données 2.1.1 Structure d’import On va d’abord importer une donnée dans R, de la façon suivante : nom_du_fichier &lt;- read_extension(&quot;chemin_du_fichier.extension&quot;) Cette instruction comprend 4 éléments : Le nom de la table cible : nom_du_fichier. Son choix est libre mais ne doit pas comprendre d’espaces ou d’accents ; Le pointeur : &lt;-, qui permet de remplir la table cible ; Une fonction de lecture : read_extension() qui diffère selon le type de fichier ; Le chemin du fichier, entre guillemets : \"chemin_du_fichier.extension\". Comme on se situe dans un projet RStudio, celui-ci part de la racine du projet. VOtre console peut vous renvoyer certaines informations sur la façon dont R encode les colonnes (en numérique, en caractère, etc.). 2.1.2 Exemples Le package readxl nous permet d’importer des fichiers Excel. Par exemple ici pour le fichier bmo_2019_idf.xlsx qui se situe dans le dossier data : bmo_secteur &lt;- read_xlsx(&quot;data/dataset/bmo_2019_secteur.xlsx&quot;) Si le fichier avait été : en .xls, l’instruction aurait été read_xls ; en .csv, read_csv2()du package readr ; en SAS (en .sas7bdat), read_sas du package haven ; dans d’autres formats, il existe des fonctions spécifiques. 2.1.3 Afficher la table On peut ensuite afficher la table de données importée de deux façons : La première consiste à l’afficher dans la console en exécutant le nom de la table. Cela affiche des informations sur le type des colonnes et le nombre de lignes et de colonnes. bmo_secteur ## # A tibble: 4,572 x 8 ## gd_secteur_bmo reg dep bassin_bmo ze nb_proj_tot nb_proj_diff nb_proj_sais ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Agriculture 01 971 0101 0101 77.0 58.5 26.5 ## 2 Agriculture 01 971 0101 0102 180. 40.9 0 ## 3 Agriculture 01 971 0102 0106 119. 67.0 94.0 ## 4 Agriculture 01 971 0103 0103 25.8 25.8 13.8 ## 5 Agriculture 01 971 0105 0101 26.4 5.47 5.47 ## 6 Agriculture 02 972 0201 0201 37.3 33.3 0 ## 7 Agriculture 02 972 0202 0204 92.2 19.7 69.6 ## 8 Agriculture 02 972 0202 0206 174. 84.0 85.6 ## 9 Agriculture 02 972 0203 0202 52.6 7.56 52.6 ## 10 Agriculture 02 972 0203 0203 173. 49.0 138. ## # ... with 4,562 more rows La seconde consiste à visualiser la table avec l’instruction View(nom_de_la_table). Cela va afficher un onglet à part. A éviter dans le cas de grosses tables. 2.2 Pour la cartographie Pour réaliser une carte, il faut avoir une table de données à visualiser, qui comprend : un identifiant spatial : code commune, bassin, département, région, etc. ; une valeur : cela peut être une donnée continue (valeur numérique) ou discrète (classe d’une classification par exemple, discrétisation d’une valeur continue). Cette table directement importée sous ce format. Elle peut être aussi calculée avec R. Pour notre table, on somme par département puis on calcule la part de projets difficiles et on découpe en classes cette part. bmo_dep &lt;- bmo_secteur %&gt;% group_by(dep) %&gt;% summarise(nb_proj_tot = sum(nb_proj_tot), nb_proj_diff = sum(nb_proj_diff)) %&gt;% mutate( part_diff = nb_proj_diff / nb_proj_tot * 100, part_diff_classes = cut( part_diff, include.lowest = TRUE, breaks = c(0, 40, 50, 60, 100), labels = c(&quot;Moins de 40 %&quot;, &quot;40-50 %&quot;, &quot;50-60 %&quot;, &quot;60% et plus&quot;) ) ) La table aura alors la forme suivante : bmo_dep ## # A tibble: 104 x 5 ## dep nb_proj_tot nb_proj_diff part_diff part_diff_classes ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 01 18464. 10859. 58.8 50-60 % ## 2 02 18418. 9851. 53.5 50-60 % ## 3 03 9394. 4517. 48.1 40-50 % ## 4 04 9686. 4509. 46.6 40-50 % ## 5 05 12376. 5166. 41.7 40-50 % ## 6 06 54174. 25030. 46.2 40-50 % ## 7 07 15975. 7351. 46.0 40-50 % ## 8 08 6233. 3422. 54.9 50-60 % ## 9 09 6454. 2327. 36.1 Moins de 40 % ## 10 10 15068. 6773. 44.9 40-50 % ## # ... with 94 more rows "],
["prep-data.html", "3 Recoder vos données", " 3 Recoder vos données Vos tables de données ne seront pas forcément propres ou au bon format lorsque vous les importerez. Il importe donc de les recoder. Pour ces opérations, vous pouvez vous reporter au manuel de Julien Barnier, Introduction à R et au tidyverse qui offre de façon pédagogique et rapide un bon aperçu de ces méthodes de recodage : https://juba.github.io/tidyverse/ On pourra particulièrement se concentrer sur les chapitres 9 (Recoder des variables) et 10 (Manipuler des données avec dplyr), qui permettront de balayer la majeure partie des besoins pour la cartographie. "],
["import-sf.html", "4 Données spatiales 4.1 Les données vectorielles 4.2 Importer des données spatiales 4.3 Opérations sur données spatiales 4.4 Ajouter de l’information statistique", " 4 Données spatiales 4.1 Les données vectorielles 4.1.1 Qu’est-ce qu’une donnée vectorielle ? Pour pouvoir représenter une carte, il faut importer un “fond de carte” sur lequel on va appliquer nos valeurs. Il est composé de données dites “vectorielles”, qui correspondent à une géométrie : des polygones, par exemple une zone admistrative : région, département, bassin d’emploi, etc. ; des lignes, comme des routes ou des lignes de train ; des points, à l’instar des centres des communes, de la localisation des agences Pôle emploi ou des adresses des demandeurs d’emploi. 4.1.2 Le format shapefile La donnée vectorielle est stockée dans un ensemble de fichier qu’on appelle des shapefiles (ou “fichier de forme”). Il comprend plusieurs fichiers, avec un nom identique et des formats différents, par exemple .shp, .dbf, .prj, etc. Ces fichiers fonctionnent ensemble et on a besoin de l’ensemble pour utiliser la donnée vectorielle. Il est donc important de ne pas les séparer. 4.1.3 A Pôle emploi On a construit ou récupéré les principaux fonds de carte utilisés à Pôle emploi qui sont disponibles ici : https://github.com/tvroylandt/r-cartostat/tree/master/data/shp Ces cartes ne sont pas géographiquement exactes puisqu’elles incluent les DOMs rapprochés de la France métropolitaine ainsi qu’un zoom sur l’Île-de-France. Les cartes sont les suivantes : communes ; bassin BMO ; zone d’emploi ; département ; région. Le détail de leur construction est disponible en annexe @ref(annexe_fond_carte) 4.2 Importer des données spatiales La fonction st_read(), du package sf, va nous permettre de lire ces fichiers. Il faut lui spécifier le chemin vers le fichier .shp. Exemple ici avec l’import des départements. shp_dep &lt;- st_read(here(&quot;data/shp/FR_DEP_DOM_IDF.shp&quot;)) ## Reading layer `FR_DEP_DOM_IDF&#39; from data source `D:\\r-cartostat\\data\\shp\\FR_DEP_DOM_IDF.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 109 features and 3 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 101171.8 ymin: 5991180 xmax: 1242086 ymax: 7283392 ## epsg (SRID): NA ## proj4string: +proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +units=m +no_defs On peut en visualiser le contenu. On observe qu’on a un fichier avec une colonne DEP, qui contient le code du département, ainsi qu’une colonne geometry qui contient les spécifications spatiales. shp_dep ## # A tibble: 109 x 4 ## code_reg code_dep zoom_idf geometry ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;MULTIPOLYGON [m]&gt; ## 1 01 971 0 (((359926.3 6062079, 359394.4 6061722, 358910.3 6061434, 358481.5 6061211, 35811~ ## 2 02 972 0 (((518712.6 6008907, 518514.6 6008430, 518289.9 6007830, 518041.7 6007087, 51777~ ## 3 03 973 0 (((675660.3 6033423, 675054 6032020, 674433.4 6030537, 673804.1 6028989, 673177.~ ## 4 04 974 0 (((835255.3 5992635, 833869 5993057, 832318.9 5993538, 830628.8 5994069, 828855.~ ## 5 06 976 0 (((1012993 6063103, 1013066 6062251, 1013082 6061367, 1013047 6060461, 1012968 6~ ## 6 11 75 0 (((645954.9 6860778, 645557.8 6861074, 645271.2 6861383, 645081.6 6861705, 64498~ ## 7 11 75 1 (((1008050 7186125, 1007383 7186590, 1006738 7187093, 1006113 7187641, 1005523 7~ ## 8 11 77 0 (((689514.7 6783195, 688908.1 6782948, 688323.5 6782740, 687759.3 6782598, 68721~ ## 9 11 77 1 (((1106529 7018070, 1105773 7017682, 1105044 7017248, 1104328 7016771, 1103609 7~ ## 10 11 78 0 (((615951.3 6817188, 615344.4 6817347, 614746.5 6817560, 614173.1 6817825, 61363~ ## # ... with 99 more rows 4.3 Opérations sur données spatiales De la même façon que pour une table normale, on peut faire des opérations sur un fichier spatial. 4.3.1 Filtre On peut filtrer sur une zone en utilisant filter(). Par exemple si je ne souhaite que l’Oise. shp_dep %&gt;% filter(code_dep == &quot;60&quot;) ## # A tibble: 1 x 4 ## code_reg code_dep zoom_idf geometry ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;MULTIPOLYGON [m]&gt; ## 1 32 60 0 (((702185.7 6904719, 702056.5 6904229, 701890.5 6903802, 701677.5 6903440, 701404~ 4.3.2 Modification de colonnes Je peux créer des colonnes, par exemple en regroupant les départements en régions. shp_dep_recode &lt;- shp_dep %&gt;% mutate(REG = fct_collapse( code_dep, &quot;Hauts-de-France&quot; = c(&quot;02&quot;, &quot;59&quot;, &quot;60&quot;, &quot;62&quot;, &quot;80&quot;), &quot;Ile-de-France&quot; = c(&quot;75&quot;, &quot;77&quot;, &quot;78&quot;, &quot;91&quot;, &quot;92&quot;, &quot;93&quot;, &quot;94&quot;, &quot;95&quot;) )) %&gt;% filter(REG %in% c(&quot;Hauts-de-France&quot;, &quot;Ile-de-France&quot;) &amp; zoom_idf == &quot;0&quot;) shp_dep_recode ## # A tibble: 13 x 5 ## code_reg code_dep zoom_idf geometry REG ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;MULTIPOLYGON [m]&gt; &lt;fct&gt; ## 1 11 75 0 (((645954.9 6860778, 645557.8 6861074, 645271.2 6861383, 645081.6 68~ Ile-de-Fra~ ## 2 11 77 0 (((689514.7 6783195, 688908.1 6782948, 688323.5 6782740, 687759.3 67~ Ile-de-Fra~ ## 3 11 78 0 (((615951.3 6817188, 615344.4 6817347, 614746.5 6817560, 614173.1 68~ Ile-de-Fra~ ## 4 11 91 0 (((629356.9 6799504, 628610.1 6799526, 627898.9 6799572, 627224 6799~ Ile-de-Fra~ ## 5 11 92 0 (((650014.2 6852247, 649886.1 6851558, 649741.5 6850899, 649577.9 68~ Ile-de-Fra~ ## 6 11 93 0 (((661168 6861732, 660507.1 6861841, 659895.6 6861922, 659320.2 6862~ Ile-de-Fra~ ## 7 11 94 0 (((659019.6 6847815, 658282.6 6847870, 657486.1 6847977, 656638.9 68~ Ile-de-Fra~ ## 8 11 95 0 (((611585.6 6885483, 610823.2 6885356, 610065.5 6885180, 609317 6884~ Ile-de-Fra~ ## 9 32 02 0 (((749009.6 6913220, 748583.3 6912897, 748221.7 6912540, 747909.7 69~ Hauts-de-F~ ## 10 32 59 0 (((717452.5 6991864, 716827.6 6991734, 716221.5 6991597, 715614.3 69~ Hauts-de-F~ ## 11 32 60 0 (((702185.7 6904719, 702056.5 6904229, 701890.5 6903802, 701677.5 69~ Hauts-de-F~ ## 12 32 62 0 (((641967.1 7013097, 641207.3 7012989, 640481.3 7012884, 639760.2 70~ Hauts-de-F~ ## 13 32 80 0 (((639052.2 6955744, 638234.4 6955792, 637355.8 6955837, 636425.4 69~ Hauts-de-F~ 4.3.3 Regroupement Je peux regrouper des données pour donner des ensembles plus grands. shp_reg_hdf_idf &lt;- shp_dep_recode %&gt;% group_by(REG) %&gt;% summarise() shp_reg_hdf_idf ## # A tibble: 2 x 2 ## REG geometry ## &lt;fct&gt; &lt;GEOMETRY [m]&gt; ## 1 Hauts-de-France POLYGON ((707415.3 6890986, 707025.7 6890453, 706564.4 6889858, 706081.1 6889279, 705577.8 6~ ## 2 Ile-de-France MULTIPOLYGON (((629356.9 6799504, 628610.1 6799526, 627898.9 6799572, 627224 6799645, 626587~ De fait, avec un fichier communal et des tables de passages, on peut recréer l’ensemble des niveaux. C’est d’ailleurs ainsi que l’on a procédé pour créer les fonds de carte. –&gt; LIEN VERS LE CODE 4.3.4 Enlever la colonne geometry Pour enlever la couche de données spatiales, on utilisera st_drop_geometry(). 4.4 Ajouter de l’information statistique On va ensuite ajouter l’information spatiale au fond de carte, en réalisant une jointure. On part toujours du fond de carte pour la jointure. On s’aperçoit alors qu’on a, pour chaque zone géographique, la difficulté de recrutement, en %. bmo_dep_shp &lt;- shp_dep %&gt;% left_join(bmo_dep, by = c(&quot;code_dep&quot; = &quot;dep&quot;)) ## Warning: Column `code_dep`/`dep` joining factor and character vector, coercing into character vector bmo_dep_shp ## # A tibble: 109 x 8 ## code_reg code_dep zoom_idf nb_proj_tot nb_proj_diff part_diff part_diff_classes geometry ## &lt;fct&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;MULTIPOLYGON [m]&gt; ## 1 01 971 0 12938. 5249. 40.6 40-50 % (((359926.3 6062079, 359394~ ## 2 02 972 0 11407. 5307. 46.5 40-50 % (((518712.6 6008907, 518514~ ## 3 03 973 0 6677. 3296. 49.4 40-50 % (((675660.3 6033423, 675054~ ## 4 04 974 0 31667. 10310. 32.6 Moins de 40 % (((835255.3 5992635, 833869~ ## 5 06 976 0 5309. 2259. 42.6 40-50 % (((1012993 6063103, 1013066~ ## 6 11 75 0 173662. 75181. 43.3 40-50 % (((645954.9 6860778, 645557~ ## 7 11 75 1 173662. 75181. 43.3 40-50 % (((1008050 7186125, 1007383~ ## 8 11 77 0 34753. 17111. 49.2 40-50 % (((689514.7 6783195, 688908~ ## 9 11 77 1 34753. 17111. 49.2 40-50 % (((1106529 7018070, 1105773~ ## 10 11 78 0 47079. 25389. 53.9 50-60 % (((615951.3 6817188, 615344~ ## # ... with 99 more rows Pour n’avoir qu’une région, il suffit de filtrer en amont sur le fond de carte, exemple avec les Hauts-de-France. bmo_dep_shp_hdf &lt;- shp_dep %&gt;% filter(code_dep %in% c(&quot;60&quot;, &quot;02&quot;, &quot;80&quot;, &quot;59&quot;, &quot;62&quot;)) %&gt;% left_join(bmo_dep, by = c(&quot;code_dep&quot; = &quot;dep&quot;)) ## Warning: Column `code_dep`/`dep` joining factor and character vector, coercing into character vector bmo_dep_shp_hdf ## # A tibble: 5 x 8 ## code_reg code_dep zoom_idf nb_proj_tot nb_proj_diff part_diff part_diff_classes geometry ## &lt;fct&gt; &lt;chr&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; &lt;MULTIPOLYGON [m]&gt; ## 1 32 02 0 18418. 9851. 53.5 50-60 % (((749009.6 6913220, 748583.~ ## 2 32 59 0 95022. 45883. 48.3 40-50 % (((717452.5 6991864, 716827.~ ## 3 32 60 0 25263. 12977. 51.4 50-60 % (((702185.7 6904719, 702056.~ ## 4 32 62 0 45805. 22472. 49.1 40-50 % (((641967.1 7013097, 641207.~ ## 5 32 80 0 19338. 8677. 44.9 40-50 % (((639052.2 6955744, 638234.~ "],
["maps-ggplot.html", "5 Réaliser les cartes 5.1 Fonctionnement de ggplot2 5.2 Pour la cartographie", " 5 Réaliser les cartes 5.1 Fonctionnement de ggplot2 Pour construire des cartes, on utilise le package ggplot2. Celui-ci nécessite un certain nombre d’éléments : la donnée : on va lui rentrer en entrée une table ; les variables à représenter, à inclure dans l’instruction aes(); les paramètres supplémentaires ; les formes, qui comment par geom_XXX() : quelle représentation s’appliquera aux variables et aux paramètres ; des fonctions qui spécifient l’échelle, le thème, etc. ggplot2 a un fonctionnement par couches, c’est-à-dire qu’on additionne les éléments au fur et à mesure. On lui déclare qu’on veut utiliser le package par l’instruction ggplot() et on ajoute ensuite les couches les unes après les autres avec le +. ggplot() + &lt;FORME&gt;(data = &lt;DATA&gt;, aes(&lt;VARIABLES&gt;), ...= &lt;PARAMS&gt;) + &lt;FONCTION1&gt; La donnée peut se spécifier au niveau du ggplot(data = &lt;DATA&gt;), elle s’appliquera alors à l’ensemble des formes et fonctions, ou au niveau de chaque forme, où elle s’appliquera uniquement à la forme. 5.2 Pour la cartographie Il existe une forme spécifique pour afficher des données spatiales : geom_sf(). 5.2.1 Spécifier la table de données Dans un premier temps, on va lui spécifier quelles sont les données à utiliser, cela nous affiche la carte vide, avec les limites pour chaque unité. ggplot() + geom_sf(data = bmo_dep_shp) On peut jouer sur les paramètres pour élargir ou changer la couleur des frontières. ggplot() + geom_sf(data = bmo_dep_shp, color = &quot;red&quot;, size = 1.1) 5.2.2 Afficher plusieurs couches de données On peut vouloir afficher plusieurs couches de données, par exemple quand on affiche les départements et qu’on veut représenter les limites régionales. On ajoute alors la couche régionale au dessus de la couche départementale. Les limites des régions vont alors se superposer aux limites des départements. On utilise le paramètre alpha = 0 pour lui préciser qu’on souhaite que l’intérieur des zones soit transparente. ggplot() + geom_sf(data = bmo_dep_shp, color = &quot;red&quot;, size = 0.9) + geom_sf(data = reg_shp, color = &quot;blue&quot;, size = 1.1, alpha = 0) "],
["maps-color.html", "6 Aplats de couleurs 6.1 Spécifier la variable à représenter 6.2 Afficher les valeurs", " 6 Aplats de couleurs Les étapes pour réaliser des cartes dites “chroplèthes” ou “par aplats de couleurs” sont détaillées ici. Ces cartes sont notamment intéressantes quand on veut représenter une proportion ou l’appartenance à une classe. 6.1 Spécifier la variable à représenter On va dire quelle variable on souhaite représenter dans l’instruction aes(). Cette variable doit remplir les aires des polygones, on spécifie donc aes(fill = &lt;VARIABLE&gt;). Cette variable doit exister dans la table de donnée. 6.1.1 Continue Elle peut être continue, auquel cas on aura une échelle continue. ggplot() + geom_sf(data = bmo_dep_shp, aes(fill = part_diff)) 6.1.2 Discrète Ou discrète où on aura une échelle discrète : ggplot() + geom_sf(data = bmo_dep_shp, aes(fill = part_diff_classes)) 6.2 Afficher les valeurs Souvent, on souhaite afficher, au niveau de la zone géographique, la valeur qui s’affiche, ou le nom de la zone. Cette opération peut se réaliser par l’ajout d’une couche supplémentaire : geom_sf_label() ou geom_sf_text(). Les deux font la même chose, l’aspect est légèrement différent. Pour que cela fonctionne, il faut lui préciser une valeur à afficher dans aes(label = ), par exemple, la part de projets difficiles (qu’on arrondi au dixième). Comme cette valeur doit se référer à une table de donnée, on a placé celle-ci directement dans le ggplot(). On peut passer des paramètres, comme la taille par exemple. ggplot(data = bmo_dep_shp) + geom_sf(aes(fill = part_diff_classes)) + geom_sf_text(aes(label = round(part_diff, 1)), size = 2.5) "],
["maps-circle.html", "7 Cercles proportionnels 7.1 Principe 7.2 Personnalisation", " 7 Cercles proportionnels Un autre type de carte représente chaque valeur par un cercle proportionnel et éventuellement une couleur. Ces cartes permettent de mettre en valeur les volumes. 7.1 Principe On les réalise à l’aide de la fonction stat_sf_coordinates(). On procède en plusieurs étapes : on affiche d’abord le fond de carte à vide ; on lui spécifie les valeurs à afficher, ici sur le nombre de projets : nb_proj_tot ; on personnalise ensuite les paramètres des points à afficher, par exemple en ajoutant une couleur, la part de projets difficiles, en classes. ggplot(data = bmo_dep_shp) + geom_sf() + stat_sf_coordinates(aes(size = nb_proj_tot, color = part_diff_classes)) 7.2 Personnalisation On peut jouer sur les paramètres pour afficher d’autres formes. Pour en savoir plus, on peut se reporter aux spécifications du paramètre shape : https://ggplot2.tidyverse.org/articles/ggplot2-specs.html Cela peut supposer de modifier la façon de passer les variables (avec fill plutôt que color par exemple). 7.2.1 Des triangles ggplot(data = bmo_dep_shp) + geom_sf() + stat_sf_coordinates(aes(size = nb_proj_tot, fill = part_diff_classes), shape = 24, color = &quot;black&quot;) 7.2.2 Des carrés ggplot(data = bmo_dep_shp) + geom_sf() + stat_sf_coordinates(aes(size = nb_proj_tot, fill = part_diff_classes), shape = 22, color = &quot;black&quot;) "],
["maps-aspect.html", "8 Personnaliser vos cartes 8.1 Les échelles 8.2 Titre et légende 8.3 Le thème", " 8 Personnaliser vos cartes 8.1 Les échelles Les échelles se personnalisent avec une fonction du type scale_xxx_type() où xxx est correspond à la modalité d’affichage de notre variable dans aes() (par exemple fill, color, size) ; type au type de l’échelle (discrète, continue, manuelle, en gradient, etc.). Une échelle correspond toujours à une variable déclarée dans aes(). On peut déclarer le nom de la légende avec name =. D’autres paramètres s’ajoutent en fonction de l’échelle. Vous pouvez en savoir plus ici : https://ggplot2.tidyverse.org/reference/index.html#section-scales 8.1.1 Echelles de couleur continues Pour les variables continues, on privilégiera scale_xxx_gradient(), qui affiche un gradient de couleur où on lui donne la couleur basse et haute. ggplot() + geom_sf(data = bmo_dep_shp, aes(fill = part_diff)) + scale_fill_gradient(name = &quot;Difficulté de recrutement&quot;, low = &quot;white&quot;, high = &quot;red&quot;) Dans le cas où on a deux gammes de valeurs, par exemple négatives et positives, on peut utiliser scale_xxx_gradient2() qui comprend un paramètre mid, pour la valeur du milieu. 8.1.2 Echelles de couleur manuelles Pour les échelles discrètes, il peut être intéressant de préciser manuellement les couleurs que l’on souhaite voir apparaître, soit avec leur nom, soit avec leur code (https://www.colorhexa.com/). On utilise alors scale_xxx_manual(). Par exemple ici sur le remplissage des zones : ggplot() + geom_sf(data = bmo_dep_shp, aes(fill = part_diff_classes)) + scale_fill_manual(name = &quot;Difficulté de recrutement&quot;, values = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;)) Ou pour la couleur de points : ggplot(data = bmo_dep_shp) + geom_sf() + stat_sf_coordinates(aes(size = nb_proj_tot, color = part_diff_classes)) + scale_color_manual(name = &quot;Difficulté de recrutement&quot;, values = c(&quot;#db4545&quot;, &quot;#c72626&quot;, &quot;#9d1e1e&quot;, &quot;#721616&quot;)) 8.1.3 Echelles de couleur existantes Un certain nombre d’échelles de couleurs sont déjà inclus dans le package. On peut particulièrement recommander les palettes issues de viridis, qui sont spécialement pensées pour être adaptées aux personnes souffrant de déficience visuelle. Elles peuvent avoir des difficultées à distinguer certaines couleurs ou différences de couleurs. Plus d’informations : https://ggplot2.tidyverse.org/reference/scale_viridis.html On s’y réfère par scale_xxx_viridis_d() pour les palettes discrètes et scale_xxx_viridis_c() pour les palettes continues. On peut aussi régler le sens de la palette avec direction. ggplot() + geom_sf(data = bmo_dep_shp, aes(fill = part_diff_classes)) + scale_fill_viridis_d(direction = -1) ggplot(data = bmo_dep_shp) + geom_sf() + stat_sf_coordinates(aes(size = nb_proj_tot, color = part_diff)) + scale_color_viridis_c(option = &quot;inferno&quot;) 8.1.4 Autres échelles On utilisera aussi scale pour régler les autres paramètres, par exemple la taille des points, ici en précisant une rangée de valeurs (range =), ce qui augmente l’écart entre la taille des points. ggplot(data = bmo_dep_shp) + geom_sf() + stat_sf_coordinates(aes(size = nb_proj_tot), shape = 22, fill = &quot;red&quot;) + scale_size_continuous(name = &quot;Nombre de projets&quot;, range = c(1, 10)) Le même principe peut s’appliquer aux autres paramètres passés dans aes(). 8.2 Titre et légende La fonction labs() permet d’ajouter un titre et une légende. ggplot() + geom_sf(data = bmo_dep_shp, aes(fill = part_diff_classes)) + scale_fill_viridis_d(name = &quot;&quot;, option = &quot;inferno&quot;, direction = -1) + labs(title = &quot;Part des projets difficiles&quot;, caption = &quot;Source : BMO 2019&quot;) 8.3 Le thème La thème (theme()) contient tous les éléments de personnalisation de votre graphique. Il y en a beaucoup et vous pouvez pousser très loin : https://ggplot2.tidyverse.org/reference/theme.html. On se contentera ici d’appliquer un thème prédéfini : theme_void(), qui retire le fond gris et les axes. ggplot() + geom_sf(data = bmo_dep_shp, aes(fill = part_diff_classes)) + scale_fill_viridis_d(name = &quot;&quot;, option = &quot;inferno&quot;, direction = -1) + labs(title = &quot;Part des projets difficiles&quot;, caption = &quot;Source : BMO 2019&quot;) + theme_void() Notre carte a maintenant son aspect définitif. "],
["export.html", "9 Exporter vos résultats 9.1 Avec l’outil d’export 9.2 Avec ggsave", " 9 Exporter vos résultats 9.1 Avec l’outil d’export RStudio propose un outil d’export lorsqu’on affiche un graphique. Il suffit de cliquer dessus pour faire apparaître une console. On spécifie alors le dossier, le nom du fichier et les dimensions et exporte le résultat. Cet outil a comme avantage d’être simple. Ses inconvénients majeurs sont : clique-bouton : on ne peut pas l’automatiser ; la taille par défaut de l’export dépend de la taille de l’affichage dans votre zone de graphique. 9.2 Avec ggsave On peut utiliser la fonction ggsave qui nous permet de configurer l’export. On utilise les options : filename pour le nom du fichier ; height et width pour la hauteur et la largueur ; units pour l’unité de hauteur et de largueur ; dpi pour la résolution, par défaut 300. Par défaut, le graphique sauvegardé est le dernier réalisé. ggsave( filename = &quot;chemin/nom_du_fichier.png&quot;, width = 297, height = 210, units = &quot;mm&quot;, dpi = 400 ) "],
["annexe-fond-carte.html", "A Annexe - Fonds de carte A.1 Fond de carte communal A.2 Tables de passages géographiques A.3 Agrégation des niveaux A.4 Simplification des contours A.5 Export des fonds de carte A.6 Astuce pour les zooms", " A Annexe - Fonds de carte Cet annexe détaille la construction des fonds de carte mis à disposition. A.1 Fond de carte communal On part d’un fond de carte communal, en géographie 2019, à disposition ici :https://github.com/antuki/CARTElette Il a été travaillé par Kim Antunez, de l’Insee, à partir de fonds de carte de l’IGN. A.1.1 Chargement Il est directement disponible dans le package CARTElette et on le charge ainsi. library(CARTElette) shp_commune &lt;- charger_carte(COG = 2019, nivsupra = &quot;COM&quot;) ## Reading layer `FR_COM_2019&#39; from data source `D:\\r-cartostat\\data\\shp\\init\\FR_COM_2019.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 34970 features and 11 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 99040 ymin: 5988964 xmax: 1242444 ymax: 7110479 ## epsg (SRID): NA ## proj4string: +proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +units=m +no_defs A.1.2 Gestion des DOMs Ce fond de carte inclut les DOMs à des positions qui ne sont pas géographiquement correctes mais qui les placent au même niveau que la France métropolitaine. On conservera donc ces positions. A.1.3 Gestion de l’Île-de-France On s’inspire de la façon dont sont déplacées les DOMs pour réaliser une copie zoomée de l’Île-de-France, qu’on placera en haut à droite. Cette copie est associée à une variable zoom_idf qui vaut 1 si on est sur le zoom, 0 sinon. shp_commune_idf &lt;- shp_commune %&gt;% filter(INSEE_REG == &quot;11&quot;) shp_commune_idf0 &lt;- shp_commune %&gt;% filter(INSEE_REG == &quot;11&quot;) %&gt;% mutate(zoom_idf = &quot;1&quot;) # paramètres deplace &lt;- c(-200000, 870000) zoom &lt;- 2.2 centroid_idf &lt;- shp_commune %&gt;% filter(INSEE_DEP == &quot;75&quot;) %&gt;% st_centroid() %&gt;% st_coordinates() ## Warning in st_centroid.sf(.): st_centroid assumes attributes are constant over geometries of x # déplacement shp_commune_idf &lt;- st_sf( shp_commune_idf0 %&gt;% st_drop_geometry(), geometry = ((st_geometry(shp_commune_idf0) - deplace) * zoom + deplace - centroid_idf) , crs = st_crs(shp_commune_idf0) ) # jointure shp_commune_zoom_idf &lt;- shp_commune %&gt;% mutate(zoom_idf = &quot;0&quot;) %&gt;% rbind(shp_commune_idf) A.2 Tables de passages géographiques A partir de fond de carte communal et des tables de passage vers les différents niveaux, de la bonne année, on reconstruit les différents fonds de carte. Pour une partie des niveaux (département et région), ils sont déjà dans la table communale. Pour les bassins, on a davantage de communes dans la table de passage, pour gérer d’éventuels problèmes d’historiques. Cela n’impacte pas le recodage puisqu’on n’a pas de tous. passage_commune_bassin &lt;- read_xlsx(&quot;data/passage/passage_commune_bassin_bmo.xlsx&quot;) passage_commune_ze &lt;- read_xlsx(&quot;data/passage/passage_commune_ze.xlsx&quot;) Le code département se calcule simplement à partir des 2 premiers chiffres du code commune (3 pour les DOMs). Exemple : shp_commune %&gt;% st_drop_geometry() %&gt;% mutate(code_dep = if_else( str_sub(INSEE_COM, 1, 2) == &quot;97&quot;, str_sub(INSEE_COM, 1, 3), str_sub(INSEE_COM, 1, 2) )) %&gt;% head(5) ## # A tibble: 5 x 12 ## ID STATUT INSEE_COM INSEE_ARR INSEE_DEP INSEE_REG CODE_EPCI NOM_COM_M POPULATION TYPE NOM_COM code_dep ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt; &lt;fct&gt; &lt;chr&gt; ## 1 COMMU~ Commun~ 32216 3 32 76 200072320 LOURTIES ~ 152 COM Lourti~ 32 ## 2 COMMU~ Commun~ 47033 3 47 75 200036523 BOUDY DE ~ 412 COM Boudy-~ 47 ## 3 COMMU~ Commun~ 32009 3 32 76 243200425 ARMOUS ET~ 86 COM Armous~ 32 ## 4 COMMU~ Commun~ 38225 1 38 84 243801024 AUTRANS M~ 2969 COM Autran~ 38 ## 5 COMMU~ Commun~ 62890 4 62 32 200044030 WILLEMAN 182 COM Willem~ 62 Le passage de la région peut se faire à partir du code département. Une table de passage est inclus. passage_dep_reg &lt;- read_xlsx(&quot;data/passage/passage_dep_reg.xlsx&quot;) A.3 Agrégation des niveaux Il reste à les agréger. # bassin BMO shp_bassin_bmo &lt;- shp_commune_zoom_idf %&gt;% left_join(passage_commune_bassin, by = c(&quot;INSEE_COM&quot; = &quot;code_commune&quot;)) %&gt;% group_by(code_bassin_bmo, lib_bassin_bmo, zoom_idf) %&gt;% summarise() %&gt;% ungroup() ## Warning: Column `INSEE_COM`/`code_commune` joining factor and character vector, coercing into character vector # ze shp_ze &lt;- shp_commune_zoom_idf %&gt;% left_join(passage_commune_ze, by = c(&quot;INSEE_COM&quot; = &quot;code_commune&quot;)) %&gt;% group_by(code_ze, lib_ze, zoom_idf) %&gt;% summarise() %&gt;% ungroup() ## Warning: Column `INSEE_COM`/`code_commune` joining factor and character vector, coercing into character vector # dep shp_dep &lt;- shp_commune_zoom_idf %&gt;% group_by(INSEE_REG, INSEE_DEP, zoom_idf) %&gt;% summarise() %&gt;% ungroup() # reg - sans le zoom shp_reg &lt;- shp_dep %&gt;% filter(zoom_idf == &quot;0&quot;) %&gt;% group_by(INSEE_REG) %&gt;% summarise() %&gt;% ungroup() plot(st_geometry(shp_bassin_bmo)) plot(st_geometry(shp_ze)) plot(st_geometry(shp_dep)) plot(st_geometry(shp_reg)) A.4 Simplification des contours Ces fonds de cartes ont un niveau de détail très important sur les contours. En contrepartie, ils sont plus lourds et ce détail joue parfois contre l’information qu’on veut représenter. On va donc chercher à les simplifier davantage à l’aide du package smoothr et d’un lissage en kernel. On fait une étape de simplification avec st_simplify() avant le lissage. library(smoothr) smooth_fr &lt;- function(data, tol = 1800, sm = 0.8){ data %&gt;% st_simplify(dTolerance = tol, preserveTopology = TRUE) %&gt;% smooth(method = &quot;ksmooth&quot;, smoothness = sm) } shp_bassin_bmo_simpl &lt;- smooth_fr(shp_bassin_bmo) shp_ze_simpl &lt;- smooth_fr(shp_ze) shp_dep_simpl &lt;- smooth_fr(shp_dep) shp_reg_simpl &lt;- smooth_fr(shp_reg) plot(st_geometry(shp_bassin_bmo_simpl)) plot(st_geometry(shp_ze_simpl)) plot(st_geometry(shp_dep_simpl)) plot(st_geometry(shp_reg_simpl)) A.5 Export des fonds de carte Puis à les sauvegarder. On en profite pour uniformiser les noms des variables. On a des warnings car parfois, la spécification des shapefiles coupe les noms de variables. Il faudra donc faire attention. # commune shp_commune_zoom_idf %&gt;% rename( code_com = INSEE_COM, lib_com = NOM_COM, code_dep = INSEE_DEP, code_reg = INSEE_REG ) %&gt;% select(code_com, lib_com, code_dep, code_reg, zoom_idf, geometry) %&gt;% st_write(&quot;data/shp/FR_COMMUNE_DOM_IDF_2019.shp&quot;, delete_dsn = TRUE) ## Deleting source `data/shp/FR_COMMUNE_DOM_IDF_2019.shp&#39; using driver `ESRI Shapefile&#39; ## Writing layer `FR_COMMUNE_DOM_IDF_2019&#39; to data source `data/shp/FR_COMMUNE_DOM_IDF_2019.shp&#39; using driver `ESRI Shapefile&#39; ## Writing 36238 features with 5 fields and geometry type Multi Polygon. # bassin_bmo shp_bassin_bmo_simpl %&gt;% st_write(&quot;data/shp/FR_BASSIN_BMO_DOM_IDF_2019.shp&quot;, delete_dsn = TRUE) ## Warning in abbreviate_shapefile_names(obj): Field names abbreviated for ESRI Shapefile driver ## Deleting source `data/shp/FR_BASSIN_BMO_DOM_IDF_2019.shp&#39; using driver `ESRI Shapefile&#39; ## Writing layer `FR_BASSIN_BMO_DOM_IDF_2019&#39; to data source `data/shp/FR_BASSIN_BMO_DOM_IDF_2019.shp&#39; using driver `ESRI Shapefile&#39; ## Writing 430 features with 3 fields and geometry type Unknown (any). # ze shp_ze_simpl %&gt;% st_write(&quot;data/shp/FR_ZE_DOM_IDF.shp&quot;, delete_dsn = TRUE) ## Deleting source `data/shp/FR_ZE_DOM_IDF.shp&#39; using driver `ESRI Shapefile&#39; ## Writing layer `FR_ZE_DOM_IDF&#39; to data source `data/shp/FR_ZE_DOM_IDF.shp&#39; using driver `ESRI Shapefile&#39; ## Writing 342 features with 3 fields and geometry type Unknown (any). # dep shp_dep_simpl %&gt;% rename(code_dep = INSEE_DEP, code_reg = INSEE_REG) %&gt;% st_write(&quot;data/shp/FR_DEP_DOM_IDF.shp&quot;, delete_dsn = TRUE) ## Deleting source `data/shp/FR_DEP_DOM_IDF.shp&#39; using driver `ESRI Shapefile&#39; ## Writing layer `FR_DEP_DOM_IDF&#39; to data source `data/shp/FR_DEP_DOM_IDF.shp&#39; using driver `ESRI Shapefile&#39; ## Writing 109 features with 3 fields and geometry type Unknown (any). # reg shp_reg_simpl %&gt;% rename(code_reg = INSEE_REG) %&gt;% st_write(&quot;data/shp/FR_REG_DOM.shp&quot;, delete_dsn = TRUE) ## Deleting source `data/shp/FR_REG_DOM.shp&#39; using driver `ESRI Shapefile&#39; ## Writing layer `FR_REG_DOM&#39; to data source `data/shp/FR_REG_DOM.shp&#39; using driver `ESRI Shapefile&#39; ## Writing 18 features with 1 fields and geometry type Unknown (any). A.6 Astuce pour les zooms Pour pouvoir afficher un carré autour de zones particulières, par exemples les zoomes, il faut ajouter une couche dans le rendu ggplot, avec des coordonnées précises. On calcule cette couche avec st_bbox() qui permet de créer un polygone entourant une zone. La fonction suivante permet d’agrandir la boîte. scale_bbox &lt;- function(bbox, scale){ xrange &lt;- bbox$xmax - bbox$xmin yrange &lt;- bbox$ymax - bbox$ymin bbox[1] &lt;- bbox[1] - (scale * xrange) bbox[3] &lt;- bbox[3] + (scale * xrange) bbox[2] &lt;- bbox[2] - (scale * yrange) bbox[4] &lt;- bbox[4] + (scale * yrange) bbox } # idf polygone_idf &lt;- shp_dep_simpl %&gt;% filter(zoom_idf == &quot;1&quot;) %&gt;% st_bbox() %&gt;% scale_bbox(scale = 0.05) %&gt;% st_as_sfc() # dom polygone_dom &lt;- shp_dep_simpl %&gt;% filter(INSEE_REG %in% c(&quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;06&quot;)) %&gt;% st_bbox() %&gt;% scale_bbox(scale = 0.1) %&gt;% st_as_sfc() On matérialise ici des polygones en les colorant. ggplot() + geom_sf(data = shp_dep_simpl, fill = &quot;lightblue&quot;, size = 1) + geom_sf( data = polygone_idf, fill = &quot;red&quot;, alpha = 0.5, size = 1 ) + geom_sf( data = polygone_dom, fill = &quot;green&quot;, alpha = 0.5, size = 1 ) + theme_void() En réalité, pour n’avoir que le contour, il faut configurer alpha = 0. ggplot() + geom_sf(data = shp_dep_simpl, fill = &quot;lightblue&quot;, size = 1) + geom_sf(data = polygone_idf, alpha = 0, size = 1) + geom_sf(data = polygone_dom, alpha = 0, size = 1) + theme_void() "],
["annexe-probleme.html", "B Annexe - Problèmes courants B.1 Des “trous” dans les fichiers B.2 Problèmes de projection B.3 Géocoder des adresses B.4 Tout autre problème", " B Annexe - Problèmes courants Cet annexe traite de problèmes que l’on peut éventuellement rencontrer. B.1 Des “trous” dans les fichiers Il se peut que vous ayez des trous dans les fichiers ou sur le fond de carte une fois la jointure effectuée. Cela est principalement du à une mauvaise jointure car il y a des codes communes / territoires du fond de carte qui n’existent pas dans votre fichier. Deux causes principales : Paris, Lyon et Marseille sont codés d’un côté au niveau de la ville et de l’autre au niveau des arrondissements ; Votre géographie comprend des zones périmées ou fusionnées. Par exemple : dans la STMT subsistent des vieux codes communes. ; ou alors vous voulez visualiser des résultats en bassin 2018 avec un fond de carte 2019. Deux options : la page du Code Officiel Géographique, avec des tables de passage : https://www.insee.fr/fr/information/2560452. Une version synthétique, depuis 2003, a été produite par le DMT et est disponible avec ce document ; Le package COGugaison (https://antuki.github.io/COGugaison/) peut vous aider à gérer ces problèmes. B.2 Problèmes de projection Il se peut que vos territoires apparaissent déformés, ou que quand vous tentiez de supperposer vos territoires, cela ne fonctionne pas ou donne des choses étranges. Par exemple : Il s’agit d’un problème de projection (autrement appelé de CRS - coordinate reference system). Si vous voyez ce mot apparaître dans la console, voici quelques suggestions : essayer d’ajouter st_transform(crs = 4326) après votre shapefile ; vérifiez que vous ne modifiez pas les shapefiles. B.3 Géocoder des adresses Pour géocoder des adresses, vous pouvez utiliser le package banR, qui fait appel à l’API de la Base Adresses Nationale. Plus de détails : https://cran.r-project.org/web/packages/banR/vignettes/geocode.html B.4 Tout autre problème Pour tout autre problème, vous pouvez vous reporter : à l’aide de R en faisant ?nom_de_la_fonction ; à Internet ; à la documentation disponible en bibliographie. R est un langage très utilisé et votre problème a probablement déjà été rencontré par quelqu’un d’autre. Il est possible que vous ayez à traduire en anglais votre questionnement. "]
]
