
# Préparer vos données

## Packages

R fonctionne selon une logique de modules, appelés "packages". Ils apportent de nouvelles fonctionnalités à la version de base.

### Installer les packages

La première étape est donc d'installer les packages qui nous sont utiles pour réaliser des cartes. Cette opération se réalise une fois et il n'est pas nécessaire de la répéter (cela mettra à jour le package).

Pour cela, on peut soit :

+ Utiliser RStudio qui nous propose un outil d'installation dans *Tools > Install Packages ...*. Tapez le nom des packages qui vous intéressent, séparés par un espace et appuyez sur *Install*.
+ Installer les packages en ligne de commande comme ce qui suit `install.packages(c("sf", "tidyverse"))` (pour installer les packages `sf` et `tidyverse`).

### Charger les packages

Pour faire des cartes, on va se servir de plusieurs packages :

+ `sf` qui est dédié à l'analyse spatiale ;
+ `tidyverse` qui installe et charge d'un seul coup [plusieurs packages utiles](https://www.tidyverse.org/packages/), dont :
  + `dplyr` pour la manipulation de données ;
  + `forcats` pour le recodage des facteurs ;
  + `readr` pour l'import de données ;
  + `ggplot2` pour faire des graphiques.
  
Et en fonction du format d'import des données :

+ `readxl` pour importer des fichiers Excel (.xls ou .xlsx) ;
+ `haven` pour importer des tables SAS.

On les charge dans R à l'aide de l'instruction `library(nom_du_package)` comme dans le code suivant :

```{r packages}
library(tidyverse)
library(sf)
library(readxl)
library(haven)
```

Cela peut renvoyer une erreur, par exemple :

```{r packages_error, error=TRUE}
library(tidyverses)
```

Dans ce cas, vérifiez l'orthographe du package. Si l'erreur persiste, vous avez peut-être oublié de l'installer.

Quand on utilise une fonction d'un package, on doit préalablement le déclarer avec `library()` sinon cela renvoiera une erreur.

## Importer des données

### Structure d'import

On va d'abord importer une donnée dans R, de la façon suivante :

```{r eval=FALSE}
nom_du_fichier <- read_extension("chemin_du_fichier.extension")
```

Cette instruction comprend 4 éléments :

+ Le nom de la table cible : `nom_du_fichier`. Son choix est libre mais ne doit pas comprendre d'espaces ou d'accents ;
+ Le pointeur : `<-`, qui permet de remplir la table cible ;
+ Une fonction de lecture : `read_extension()` qui diffère selon le type de fichier ;
+ Le chemin du fichier, entre guillemets : `"chemin_du_fichier.extension"`. Comme on se situe dans un projet RStudio, celui-ci part de la racine du projet.

VOtre console peut vous renvoyer certaines informations sur la façon dont R encode les colonnes (en numérique, en caractère, etc.).

### Excel

Le package `readxl` nous permet d'importer des fichiers Excel. Par exemple ici pour le fichier `bmo_2019_idf.xlsx` qui se situe dans le dossier `data` :

```{r eval=FALSE}
bmo_ile_de_france <- read_xlsx("data/bmo_2019_idf.xlsx")
```

Si le fichier avait été en .xls, l'instruction aurait été :

```{r eval=FALSE}
bmo_ile_de_france <- read_xls("data/bmo_2019_idf.xls")
```

### CSV

La fonction `read_csv2()`du package `readr` (qui se charge directement avec `library(tidyverse)`) permet de lire des fichiers csv "à la française" (séparés par des points virgules). Sinon, utilisez `read_csv()`.

```{r eval=FALSE}
bmo_ile_de_france <- read_csv2("data/bmo_2019_idf.csv")
```

### SAS

Pour une table SAS (en .sas7bdat), on utilise le package `haven`.

```{r eval=FALSE}
bmo_ile_de_france <- read_sas("data/bmo_2019_idf.sas7bdat")
```

### Rds

Le format .rds est un format de fichier propre à R qui permet un stockage efficace des données. Il se charge avec `read_rds()` du package `readr`.

```{r eval=FALSE}
bmo_ile_de_france <- read_rds("data/bmo_2019_idf.rds")
```

AFFICHER LES RESULTATS POUR LES DIFFERENTS FORMATS

### Afficher la table

On peut ensuite afficher la table de données importée de deux façons :

+ La première consiste à l'afficher dans la console en exécutant le nom de la table. Cela affiche des informations sur le type des colonnes et le nombre de lignes et de colonnes.

```{r eval=FALSE}
bmo_ile_de_france
```

MONTRER RESULTAT

+ La seconde consiste à visualiser la table avec l'instruction `View(nom_de_la_table)`. Cela va afficher un onglet à part. A éviter dans le cas de grosses tables.

CAPTURE ECRAN VIEW

## Format de fichiers

Pour réaliser une carte, il faut avoir une table de données à visualiser, qui comprend :

+ un identifiant spatial : code commune, bassin, département, région, etc. ;
+ une valeur : cela peut être une donnée continue (valeur numérique) ou discrète (classe d'une classification par exemple, discrétisation d'une valeur continue).

Cette table directement importée sous ce format.

Elle peut être aussi calculée avec R. Quelques opérations peuvent alors être utiles. Elles sont détaillées en annexes --> LIEN ANNEXE.

A PASSER EN ANNEXE

### Modifier des colonnes


### Filtrer des lignes


### Regrouper et sommer les données


### Joindre des tables


### Discrétiser des valeurs


### Recoder des facteurs





On importe ensuite les données qu'on souhaite visualiser et on en examine le contenu.

On va ici analyser la répartition du nombre de projets dans l'enquête BMO 2019 et la difficulté de recrutement pour quelques métiers. Les données ici ont été préparées en amont pour simplifier.

```{r import_dataset}
library(here)
bmo_2019 <- read_rds(here("data/dataset/bmo_2019.rds")) # cette instruction charge un fichier au format rds

bmo_2019
```

On va alors calculer une donnée par département, par exemple le nombre de projets et la difficulté par département. On découpe la difficulté en 4 classes qu'on fixe à la main.

```{r manip_dataset}
bmo_2019_dep <- bmo_2019 %>%
  group_by(dep) %>% # on regroupe ici par département
  summarise(nb_proj_tot = sum(nb_proj_tot),
            nb_proj_diff = sum(nb_proj_diff)) %>% # avant de sommer les projets et les projets difficiles
  mutate(
    part_diff = nb_proj_diff / nb_proj_tot * 100, # on calcule la part de difficiles
    part_diff_classes = cut(
      part_diff,
      include.lowest = TRUE,
      breaks = c(0, 40, 50, 60, 100),
      labels = c("Moins de 40 %", "40-50 %", "50-60 %", "60% et plus") # et on la discretise
    )
  )

bmo_2019_dep
```

## Données spatiales

On importe ensuite les données spatiales (le "fond de carte"). Ici il s'agit des départements.

```{r import_shp}
shp_dep <- st_read(here("data/shp/DEP_2018.shp")) # here renvoie au point où on démarre notre chemin
```

On peut en visualiser le contenu. On observe qu'on a un fichier avec une colonne *DEP*, qui contient le code du département, ainsi qu'une colonne *geometry* qui contient les spécifications spatiales.

```{r demo_shp}
shp_dep
```

## Jointure

L'étape suivante consiste à jointer le fond de carte avec nos données. On part toujours du fond de carte pour la jointure.

On s'aperçoit alors qu'on a, pour chaque zone géographique, les valeurs qu'on a construit plus haut.

```{r jointure}
bmo_2019_dep_shp <- shp_dep %>% 
  left_join(bmo_2019_dep, by = c("DEP" = "dep")) # on jointe les tables

bmo_2019_dep_shp 
```

Pour n'avoir qu'une région, il suffit de filtrer en amont sur le fond de carte, exemple avec les Hauts-de-France.

```{r jointure_filtre}
bmo_2019_dep_shp_idf <- shp_dep %>% 
  filter(DEP %in% c("60", "02", "80", "59", "62")) %>%  # on filtre sur une liste de départements
  left_join(bmo_2019_dep, by = c("DEP" = "dep")) # on jointe les tables

bmo_2019_dep_shp_idf
```

Résumé avec un schéma
