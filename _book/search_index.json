[
["index.html", "Cartographie avec R à l’usage des statisticiens 1 Introduction 1.1 Objectifs 1.2 Pré-requis", " Cartographie avec R à l’usage des statisticiens Thomas Vroylandt 2020-01-08 1 Introduction Ce support a été rédigé par Thomas Vroylandt, statisticien au sein de la Direction des Statistiques, des Etudes et de l’Evaluation de Pôle emploi. 1.1 Objectifs Ce guide vise à : introduire quelques notions sur les données spatiales ; permettre de représenter des valeurs sous forme de cartes par aplats de couleurs ; permettre de représenter des valeurs sous forme de cartes à ronds proportionnels ; personnaliser ces cartes ; exporter les résultats pour publication. 1.2 Pré-requis 1.2.1 Informatiques R (au moins, 3.5.0) doit être installé sur votre poste ; RStudio aussi. 1.2.2 Connaissances Vous devez avoir des notions basiques en R : écrire et exécuter un programme ; utiliser un package ; savoir ce qu’est un projet RStudio. On se placera ici uniquement dans le cadre d’un projet RStudio. –&gt; récap de ce que c’est et de comment faire. Le reste sera guidé. la référence : https://r4ds.had.co.nz/ (en anglais) ; une bonne introduction : https://juba.github.io/tidyverse/ (en français). "],
["préparer-vos-données.html", "2 Préparer vos données 2.1 Packages 2.2 Importer des données 2.3 Format de fichiers 2.4 Données spatiales 2.5 Jointure", " 2 Préparer vos données 2.1 Packages R fonctionne selon une logique de modules, appelés “packages”. Ils apportent de nouvelles fonctionnalités à la version de base. 2.1.1 Installer les packages La première étape est donc d’installer les packages qui nous sont utiles pour réaliser des cartes. Cette opération se réalise une fois et il n’est pas nécessaire de la répéter (cela mettra à jour le package). Pour cela, on peut soit : Utiliser RStudio qui nous propose un outil d’installation dans Tools &gt; Install Packages …. Tapez le nom des packages qui vous intéressent, séparés par un espace et appuyez sur Install. Installer les packages en ligne de commande comme ce qui suit install.packages(c(\"sf\", \"tidyverse\")) (pour installer les packages sf et tidyverse). 2.1.2 Charger les packages Pour faire des cartes, on va se servir de plusieurs packages : sf qui est dédié à l’analyse spatiale ; tidyverse qui installe et charge d’un seul coup plusieurs packages utiles, dont : dplyr pour la manipulation de données ; forcats pour le recodage des facteurs ; readr pour l’import de données ; ggplot2 pour faire des graphiques. Et en fonction du format d’import des données : readxl pour importer des fichiers Excel (.xls ou .xlsx) ; haven pour importer des tables SAS. On les charge dans R à l’aide de l’instruction library(nom_du_package) comme dans le code suivant : library(tidyverse) library(sf) library(readxl) library(haven) Cela peut renvoyer une erreur, par exemple : library(tidyverses) ## Error in library(tidyverses): there is no package called &#39;tidyverses&#39; Dans ce cas, vérifiez l’orthographe du package. Si l’erreur persiste, vous avez peut-être oublié de l’installer. Quand on utilise une fonction d’un package, on doit préalablement le déclarer avec library() sinon cela renvoiera une erreur. 2.2 Importer des données 2.2.1 Structure d’import On va d’abord importer une donnée dans R, de la façon suivante : nom_du_fichier &lt;- read_extension(&quot;chemin_du_fichier.extension&quot;) Cette instruction comprend 4 éléments : Le nom de la table cible : nom_du_fichier. Son choix est libre mais ne doit pas comprendre d’espaces ou d’accents ; Le pointeur : &lt;-, qui permet de remplir la table cible ; Une fonction de lecture : read_extension() qui diffère selon le type de fichier ; Le chemin du fichier, entre guillemets : \"chemin_du_fichier.extension\". Comme on se situe dans un projet RStudio, celui-ci part de la racine du projet. VOtre console peut vous renvoyer certaines informations sur la façon dont R encode les colonnes (en numérique, en caractère, etc.). 2.2.2 Excel Le package readxl nous permet d’importer des fichiers Excel. Par exemple ici pour le fichier bmo_2019_idf.xlsx qui se situe dans le dossier data : bmo_ile_de_france &lt;- read_xlsx(&quot;data/bmo_2019_idf.xlsx&quot;) Si le fichier avait été en .xls, l’instruction aurait été : bmo_ile_de_france &lt;- read_xls(&quot;data/bmo_2019_idf.xls&quot;) 2.2.3 CSV La fonction read_csv2()du package readr (qui se charge directement avec library(tidyverse)) permet de lire des fichiers csv “à la française” (séparés par des points virgules). Sinon, utilisez read_csv(). bmo_ile_de_france &lt;- read_csv2(&quot;data/bmo_2019_idf.csv&quot;) 2.2.4 SAS Pour une table SAS (en .sas7bdat), on utilise le package haven. bmo_ile_de_france &lt;- read_sas(&quot;data/bmo_2019_idf.sas7bdat&quot;) 2.2.5 Rds Le format .rds est un format de fichier propre à R qui permet un stockage efficace des données. Il se charge avec read_rds() du package readr. bmo_ile_de_france &lt;- read_rds(&quot;data/bmo_2019_idf.rds&quot;) AFFICHER LES RESULTATS POUR LES DIFFERENTS FORMATS 2.2.6 Afficher la table On peut ensuite afficher la table de données importée de deux façons : La première consiste à l’afficher dans la console en exécutant le nom de la table. Cela affiche des informations sur le type des colonnes et le nombre de lignes et de colonnes. bmo_ile_de_france MONTRER RESULTAT La seconde consiste à visualiser la table avec l’instruction View(nom_de_la_table). Cela va afficher un onglet à part. A éviter dans le cas de grosses tables. CAPTURE ECRAN VIEW 2.3 Format de fichiers Pour réaliser une carte, il faut avoir une table de données à visualiser, qui comprend : un identifiant spatial : code commune, bassin, département, région, etc. ; une valeur : cela peut être une donnée continue (valeur numérique) ou discrète (classe d’une classification par exemple, discrétisation d’une valeur continue). Cette table directement importée sous ce format. Elle peut être aussi calculée avec R. Quelques opérations peuvent alors être utiles. Elles sont détaillées en annexes –&gt; LIEN ANNEXE. A PASSER EN ANNEXE 2.3.1 Modifier des colonnes 2.3.2 Filtrer des lignes 2.3.3 Regrouper et sommer les données 2.3.4 Joindre des tables 2.3.5 Discrétiser des valeurs 2.3.6 Recoder des facteurs On importe ensuite les données qu’on souhaite visualiser et on en examine le contenu. On va ici analyser la répartition du nombre de projets dans l’enquête BMO 2019 et la difficulté de recrutement pour quelques métiers. Les données ici ont été préparées en amont pour simplifier. library(here) bmo_2019 &lt;- read_rds(here(&quot;data/dataset/bmo_2019.rds&quot;)) # cette instruction charge un fichier au format rds bmo_2019 ## # A tibble: 26,737 x 8 ## annee fap87 reg dep bassin_bmo nb_proj_tot nb_proj_diff nb_proj_sais ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2019 A0Z 01 971 0101 232. 75.8 6.55 ## 2 2019 A0Z 01 971 0102 172. 128. 163. ## 3 2019 A0Z 01 971 0103 16.8 16.8 13.8 ## 4 2019 A0Z 01 971 0105 60.8 26.5 0 ## 5 2019 A0Z 02 972 0201 53.4 32.9 2 ## 6 2019 A0Z 02 972 0202 116. 53.1 42.2 ## 7 2019 A0Z 02 972 0203 104. 30.6 76.7 ## 8 2019 A0Z 02 972 0204 33.6 18.6 10 ## 9 2019 A0Z 03 973 0301 42.7 23.5 12.8 ## 10 2019 A0Z 03 973 0302 30.1 21.1 0 ## # ... with 26,727 more rows On va alors calculer une donnée par département, par exemple le nombre de projets et la difficulté par département. On découpe la difficulté en 4 classes qu’on fixe à la main. bmo_2019_dep &lt;- bmo_2019 %&gt;% group_by(dep) %&gt;% # on regroupe ici par département summarise(nb_proj_tot = sum(nb_proj_tot), nb_proj_diff = sum(nb_proj_diff)) %&gt;% # avant de sommer les projets et les projets difficiles mutate( part_diff = nb_proj_diff / nb_proj_tot * 100, # on calcule la part de difficiles part_diff_classes = cut( part_diff, include.lowest = TRUE, breaks = c(0, 40, 50, 60, 100), labels = c(&quot;Moins de 40 %&quot;, &quot;40-50 %&quot;, &quot;50-60 %&quot;, &quot;60% et plus&quot;) # et on la discretise ) ) bmo_2019_dep ## # A tibble: 104 x 5 ## dep nb_proj_tot nb_proj_diff part_diff part_diff_classes ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 01 18464. 10859. 58.8 50-60 % ## 2 02 18418. 9851. 53.5 50-60 % ## 3 03 9394. 4517. 48.1 40-50 % ## 4 04 9686. 4509. 46.6 40-50 % ## 5 05 12376. 5166. 41.7 40-50 % ## 6 06 54174. 25030. 46.2 40-50 % ## 7 07 15975. 7351. 46.0 40-50 % ## 8 08 6233. 3422. 54.9 50-60 % ## 9 09 6454. 2327. 36.1 Moins de 40 % ## 10 10 15068. 6773. 44.9 40-50 % ## # ... with 94 more rows 2.4 Données spatiales On importe ensuite les données spatiales (le “fond de carte”). Ici il s’agit des départements. shp_dep &lt;- st_read(here(&quot;data/shp/DEP_2018.shp&quot;)) # here renvoie au point où on démarre notre chemin ## Reading layer `DEP_2018&#39; from data source `D:\\r-cartostat\\data\\shp\\DEP_2018.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 101 features and 2 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 99216.86 ymin: 5988964 xmax: 1242426 ymax: 7110480 ## epsg (SRID): NA ## proj4string: +proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +units=m +no_defs On peut en visualiser le contenu. On observe qu’on a un fichier avec une colonne DEP, qui contient le code du département, ainsi qu’une colonne geometry qui contient les spécifications spatiales. shp_dep ## Simple feature collection with 101 features and 2 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 99216.86 ymin: 5988964 xmax: 1242426 ymax: 7110480 ## epsg (SRID): NA ## proj4string: +proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +units=m +no_defs ## First 10 features: ## DEP nom geometry ## 1 01 Ain MULTIPOLYGON (((858244 6525... ## 2 02 Aisne MULTIPOLYGON (((761608 6918... ## 3 03 Allier MULTIPOLYGON (((646325 6582... ## 4 04 Alpes-de-Haute-Provence MULTIPOLYGON (((972562 6298... ## 5 05 Hautes-Alpes MULTIPOLYGON (((957775 6377... ## 6 06 Alpes-Maritimes MULTIPOLYGON (((1028846 627... ## 7 07 Ardèche MULTIPOLYGON (((816772 6361... ## 8 08 Ardennes MULTIPOLYGON (((863817 6940... ## 9 09 Ariège MULTIPOLYGON (((576341 6173... ## 10 10 Aube MULTIPOLYGON (((751637 6784... 2.5 Jointure L’étape suivante consiste à jointer le fond de carte avec nos données. On part toujours du fond de carte pour la jointure. On s’aperçoit alors qu’on a, pour chaque zone géographique, les valeurs qu’on a construit plus haut. bmo_2019_dep_shp &lt;- shp_dep %&gt;% left_join(bmo_2019_dep, by = c(&quot;DEP&quot; = &quot;dep&quot;)) # on jointe les tables ## Warning: Column `DEP`/`dep` joining factor and character vector, coercing into character vector bmo_2019_dep_shp ## Simple feature collection with 101 features and 6 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 99216.86 ymin: 5988964 xmax: 1242426 ymax: 7110480 ## epsg (SRID): NA ## proj4string: +proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +units=m +no_defs ## First 10 features: ## DEP nom nb_proj_tot nb_proj_diff part_diff part_diff_classes ## 1 01 Ain 18464.380 10858.960 58.81031 50-60 % ## 2 02 Aisne 18417.870 9850.694 53.48444 50-60 % ## 3 03 Allier 9394.243 4516.847 48.08101 40-50 % ## 4 04 Alpes-de-Haute-Provence 9686.414 4509.349 46.55334 40-50 % ## 5 05 Hautes-Alpes 12376.342 5166.157 41.74219 40-50 % ## 6 06 Alpes-Maritimes 54174.287 25029.646 46.20208 40-50 % ## 7 07 Ardèche 15975.280 7350.657 46.01270 40-50 % ## 8 08 Ardennes 6233.049 3421.614 54.89470 50-60 % ## 9 09 Ariège 6453.668 2326.595 36.05074 Moins de 40 % ## 10 10 Aube 15068.317 6772.623 44.94611 40-50 % ## geometry ## 1 MULTIPOLYGON (((858244 6525... ## 2 MULTIPOLYGON (((761608 6918... ## 3 MULTIPOLYGON (((646325 6582... ## 4 MULTIPOLYGON (((972562 6298... ## 5 MULTIPOLYGON (((957775 6377... ## 6 MULTIPOLYGON (((1028846 627... ## 7 MULTIPOLYGON (((816772 6361... ## 8 MULTIPOLYGON (((863817 6940... ## 9 MULTIPOLYGON (((576341 6173... ## 10 MULTIPOLYGON (((751637 6784... Pour n’avoir qu’une région, il suffit de filtrer en amont sur le fond de carte, exemple avec les Hauts-de-France. bmo_2019_dep_shp_idf &lt;- shp_dep %&gt;% filter(DEP %in% c(&quot;60&quot;, &quot;02&quot;, &quot;80&quot;, &quot;59&quot;, &quot;62&quot;)) %&gt;% # on filtre sur une liste de départements left_join(bmo_2019_dep, by = c(&quot;DEP&quot; = &quot;dep&quot;)) # on jointe les tables ## Warning: Column `DEP`/`dep` joining factor and character vector, coercing into character vector bmo_2019_dep_shp_idf ## Simple feature collection with 5 features and 6 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 583917 ymin: 6859784 xmax: 790281 ymax: 7110480 ## epsg (SRID): NA ## proj4string: +proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +units=m +no_defs ## DEP nom nb_proj_tot nb_proj_diff part_diff part_diff_classes geometry ## 1 02 Aisne 18417.87 9850.694 53.48444 50-60 % MULTIPOLYGON (((761608 6918... ## 2 59 Nord 95021.95 45883.249 48.28700 40-50 % MULTIPOLYGON (((700268 7005... ## 3 60 Oise 25263.16 12976.914 51.36694 50-60 % MULTIPOLYGON (((703241 6903... ## 4 62 Pas-de-Calais 45804.86 22472.133 49.06058 40-50 % MULTIPOLYGON (((642827 7013... ## 5 80 Somme 19338.17 8677.044 44.87004 40-50 % MULTIPOLYGON (((634135 6954... Résumé avec un schéma "],
["réaliser-les-cartes.html", "3 Réaliser les cartes 3.1 Le bloc commun 3.2 Carte choroplèthe 3.3 Carte avec cercles proportionnels 3.4 Ajouter les valeurs", " 3 Réaliser les cartes 3.1 Le bloc commun On utilise le package ggplot2 (inclus dans le tidyverse chargé au début) qui nous permet de faire des graphiques par couches. Dans un premier temps, on va lui spécifier quelles sont les données à utiliser, cela nous affiche la carte vide. ggplot() + geom_sf(data = bmo_2019_dep_shp) # l&#39;instruction geom_sf() permet d&#39;afficher un objet spatial 3.2 Carte choroplèthe Le type de carte le plus simple à réaliser sont les cartes par aplats de couleur ou “choroplèthe”. Pour chaque zone, on va représenter la valeur par une couleur. On peut ensuite lui dire quelle valeur on souhaite afficher, par exemple la difficulté de recrutement en classes. C’est une variable catégorielle qui s’affiche donc comme telle. ggplot() + geom_sf(data = bmo_2019_dep_shp, # on précise la donnée à prendre par data = aes(fill = part_diff_classes)) # les variables à utiliser sont toujours mises dans un bloc aes() (pour aesthetics) On va ensuite rajouter différentes couches. Tout d’abord pour gérer l’échelle. ggplot() + geom_sf(data = bmo_2019_dep_shp, aes(fill = part_diff_classes)) + scale_fill_manual(name = &quot;&quot;, # chaque échelle commence par scale_* values = c(&quot;#ffb59a&quot;, &quot;#ff7d4d&quot;, &quot;#ff4500&quot;, &quot;#cc3700&quot;)) # elle s&#39;applique à un élément de aes, ici fill (remplissage), avec un type, ici manual puisqu&#39;on définit manuellement On va ensuite ajouter des élements de titre et de légende par exemple, ainsi qu’un thème pour avoir un fond blanc. ggplot() + geom_sf(data = bmo_2019_dep_shp, aes(fill = part_diff_classes)) + scale_fill_manual(name = &quot;&quot;, values = c(&quot;#ffb59a&quot;, &quot;#ff7d4d&quot;, &quot;#ff4500&quot;, &quot;#cc3700&quot;)) + # on lui précise des couleurs avec leurs codes labs(title = &quot;Part des recrutements difficiles en 2019 \\npar département&quot;, # labs sert à préciser le titre, la légende, etc.. caption = &quot;Source : Pôle emploi, enquête Besoins en main d&#39;oeuvre&quot;) + theme_void() + # on applique un thème blanc theme(plot.caption = element_text(hjust = 0)) # on lui précise de mettre la légende à gauche On peut faire de même avec une variable numérique. L’échelle va alors être continue et il faut préciser les couleurs qu’on souhaite en bornes. ggplot() + geom_sf(data = bmo_2019_dep_shp, aes(fill = part_diff)) + scale_fill_gradient(name = &quot;&quot;, # le scale ici est un gradient, donc une suite continue de valeurs low = &quot;white&quot;, high = &quot;purple&quot;) + # on va en préciser les bornes inférieures et supérieures theme_void() On peut ensuite exporter cette carte en cliquant sur Export. 3.3 Carte avec cercles proportionnels Un autre type de carte représente chaque valeur par un cercle proportionnel et éventuellement une couleur. Pour la réaliser, on va construire un jeu de données localisé au niveau du centroïde (barycentre) de chaque zone. On repart de la table jointée. bmo_2019_dep_shp_centre &lt;- bmo_2019_dep_shp %&gt;% st_centroid() # cette fonctionne transforme un polygone en son centroid (un point) ## Warning in st_centroid.sf(.): st_centroid assumes attributes are constant over geometries of x On va ensuite afficher la carte et au dessus les points, en tant que deuxième couche, en lui précisant qu’on souhaite que la taille soit proportionnelle au nombre de projets et la couleur à la difficulté. ggplot() + geom_sf(data = bmo_2019_dep_shp) + # on affiche une première fois les zones geom_sf(data = bmo_2019_dep_shp_centre, aes(size = nb_proj_tot, color = part_diff)) # puis les points, en précisant leur taille et couleur De la même façon que précédemment, on va régler les caractéristiques avec des échelles. En variant la forme (shape), on peut afficher des carrés, des triangles, etc. ggplot() + geom_sf(data = bmo_2019_dep_shp) + geom_sf(data = bmo_2019_dep_shp_centre, aes(size = nb_proj_tot, fill = part_diff), shape = 21, color = &quot;black&quot;) + # on en précise la forme (un rond à remplir avec fill) scale_fill_gradient(name = &quot;&quot;, low = &quot;white&quot;, high = &quot;red&quot;) + scale_size_continuous(range = c(0.5, 12)) + labs(title = &quot;Nombre de projets et \\npart des recrutements difficiles en 2019 \\npar département&quot;, caption = &quot;Source : Pôle emploi, enquête Besoins en main d&#39;oeuvre \\nLes cercles sont proportionnels au nombre de projets. La couleur indique la difficulté&quot;) + guides(size = FALSE) + # guides sert à dire de masquer la légende de taille theme_void() + theme(plot.caption = element_text(hjust = 0)) 3.4 Ajouter les valeurs Pour afficher les valeurs sur la carte, on repart des centroïdes. On en extrait les coordonnées pour avoir pour chaque point, localisé par un X et un Y, une valeur à afficher. bmo_2019_dep_shp_centre_label &lt;- bmo_2019_dep_shp_centre %&gt;% st_coordinates() %&gt;% # on récupère les coordonnées des centroids as_tibble() %&gt;% bind_cols(part_diff = bmo_2019_dep_shp_centre$part_diff) %&gt;% # on ajoute la colonne à afficher mutate(part_diff = paste0(round(part_diff, 0), &quot;%&quot;)) # on l&#39;arrondi à 0 en ajoutant un % derrière bmo_2019_dep_shp_centre_label ## # A tibble: 101 x 3 ## X Y part_diff ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 881439. 6558221. 59% ## 2 740400. 6940204. 53% ## 3 714465. 6588216. 48% ## 4 959608. 6339443. 47% ## 5 958609. 6401410. 42% ## 6 1030352. 6324028. 46% ## 7 812754. 6406862. 46% ## 8 818627. 6947523. 55% ## 9 577731. 6203547. 36% ## 10 786154. 6801093. 45% ## # ... with 91 more rows "],
["aplats-de-couleurs.html", "4 Aplats de couleurs", " 4 Aplats de couleurs "],
["cercles-proportionnels.html", "5 Cercles proportionnels", " 5 Cercles proportionnels "],
["personnaliser-vos-cartes.html", "6 Personnaliser vos cartes", " 6 Personnaliser vos cartes "],
["exporter-vos-résultats.html", "7 Exporter vos résultats", " 7 Exporter vos résultats "]
]
